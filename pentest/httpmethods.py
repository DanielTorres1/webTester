#!/usr/bin/python3
import argparse
import sys
from concurrent.futures import ThreadPoolExecutor
import requests
from rich.console import Console
from rich import box
from rich.table import Table
import json
from http.cookies import SimpleCookie
from bs4 import BeautifulSoup
import re
import ssl
from requests.adapters import HTTPAdapter
from urllib3.poolmanager import PoolManager

banner = "[~] HTTP Methods Tester, v1.1.3 lanscanner\n"

# ===== Custom SSL Adapter for urllib3 >= 2.0 =====
class CustomAdapter(HTTPAdapter):
    def init_poolmanager(self, connections, maxsize, block=False, **kwargs):
        ctx = ssl.create_default_context()
        ctx.set_ciphers('HIGH:!DH:!aNULL')
        self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize, block=block, ssl_context=ctx)


class Logger(object):
    def __init__(self, verbosity=0, quiet=False):
        self.verbosity = verbosity
        self.quiet = quiet

    def debug(self, message):
        if self.verbosity == 2:
            console.print("{}[DEBUG]{} {}".format("[yellow3]", "[/yellow3]", message), highlight=False)

    def verbose(self, message):
        if self.verbosity >= 1:
            console.print("{}[VERBOSE]{} {}".format("[blue]", "[/blue]", message), highlight=False)

    def info(self, message):
        if not self.quiet:
            console.print("{}[*]{} {}".format("[bold blue]", "[/bold blue]", message), highlight=False)

    def success(self, message):
        if not self.quiet:
            console.print("{}[+]{} {}".format("[bold green]", "[/bold green]", message), highlight=False)

    def warning(self, message):
        if not self.quiet:
            console.print("{}[-]{} {}".format("[bold orange3]", "[/bold orange3]", message), highlight=False)

    def error(self, message):
        if not self.quiet:
            console.print("{}[!]{} {}".format("[bold red]", "[/bold red]", message), highlight=False)


def get_options():
    description = "This Python script can be used for HTTP verb tampering to bypass forbidden access, and for HTTP methods enumeration to find dangerous enabled methods like PUT"

    parser = argparse.ArgumentParser(
        description=description,
        formatter_class=argparse.RawTextHelpFormatter,
    )

    parser.add_argument("url", help="e.g. https://example.com:port/path")
    parser.add_argument("-v", "--verbose", dest="verbosity", action="count", default=0, help="verbosity level (-v for verbose, -vv for debug)")
    parser.add_argument("-q", "--quiet", dest="quiet", action="store_true", default=False, help="Show no information at all")
    parser.add_argument("-k", "--insecure", dest="verify", action="store_false", default=True, required=False, help="Allow insecure server connections when using SSL (default: False)")
    parser.add_argument("-L", "--location", dest="redirect", action="store_true", default=False, required=False, help="Follow redirects (default: False)")
    parser.add_argument('-s', '--safe', action="store_true", default=None, dest='safe', help="Use only safe methods for requests (default: False)")
    parser.add_argument("-w", "--wordlist", dest="wordlist", action="store", default=None, required=False, help="HTTP methods wordlist (default is a builtin wordlist)")
    parser.add_argument("-t", "--threads", dest="threads", action="store", type=int, default=5, required=False, help="Number of threads (default: 5)")
    parser.add_argument("-j", "--jsonfile", dest="jsonfile", default=None, required=False, help="Save results to specified JSON file.")
    parser.add_argument('-x', '--proxy', action="store", default=None, dest='proxy', help="Specify a proxy to use for requests (e.g., http://localhost:8080)")
    parser.add_argument('-b', '--cookies', action="store", default=None, dest='cookies', help='Specify cookies to use in requests. (e.g., --cookies "cookie1=blah;cookie2=blah")')
    parser.add_argument('-H', '--header', default=[], dest='headers', action='append', required=False, help='Specify headers to use in requests. (e.g., --header "Header1: Value1" --header "Header2: Value2")')
    return parser.parse_args()


def methods_from_wordlist(wordlist):
    logger.verbose(f"Retrieving methods from wordlist {wordlist}")
    try:
        with open(options.wordlist, "r") as infile:
            methods += infile.read().split()
    except Exception as e:
        logger.error(f"Had some kind of error loading the wordlist ¯\\_(ツ)_/¯: {e}")


def methods_from_http_options(console, options, proxies, headers, cookies):
    options_methods = []
    logger.verbose("Pulling available methods from server with an OPTIONS request")
    try:
        r = session.options(
            url=options.url,
            proxies=proxies,
            cookies=cookies,
            headers=headers,
            allow_redirects=False,
            verify=False
        )
    except requests.exceptions.ProxyError:
        logger.error("Invalid proxy specified ")
        raise SystemExit

    if r.status_code == 200:
        logger.verbose("URL accepts OPTIONS")
        logger.debug(r.headers)
        if "Allow" in r.headers:
            for method in r.headers["Allow"].replace(" ", "").split(","):
                if method not in options_methods:
                    logger.debug(f"Adding new method {method} to methods")
                    options_methods.append(method)
                else:
                    logger.debug(f"Method {method} already in known methods, passing")
        else:
            logger.verbose("URL doesn't answer with a list of options")
    else:
        logger.verbose("URL rejects OPTIONS")
    return options_methods


def test_method(options, method, proxies, cookies, headers, results):
    try:
        r = session.request(
            method=method,
            url=options.url,
            verify=False,
            proxies=proxies,
            cookies=cookies,
            headers=headers,
            allow_redirects=False,
            stream=True,
        )
    except requests.exceptions.ProxyError:
        logger.error("Invalid proxy specified ")
        raise SystemExit
    logger.debug(f"Obtained results: {method}, {str(r.status_code)}, {str(len(r.text))}, {r.reason}")
    results[method] = {"status_code": r.status_code, "length": len(r.text), "reason": r.reason[:100], "content": r.text}


def print_results(results):
    print("Method|Status code|Reason|Length")
    for method, result in results.items():
        line = f"{method}|{result['status_code']}|{result['reason']}|{result['length']}"
        print(line)


def json_export(results, json_file):
    with open(json_file, "w") as f:
        f.write(json.dumps(results, indent=4) + "\n")


def main(options, logger, console):
    global methods
    results = {}

    # Proxy setup
    if options.proxy:
        try:
            proxies = {
                "http": "http://" + options.proxy.split('//')[1],
                "https": "http://" + options.proxy.split('//')[1]
            }
            logger.debug(f"Setting proxies to {str(proxies)}")
        except (IndexError, ValueError):
            logger.error("Invalid proxy specified ")
            sys.exit(1)
    else:
        logger.debug("Setting proxies to 'None'")
        proxies = None

    # Cookies
    cookies = {}
    if options.cookies:
        cookie = SimpleCookie()
        cookie.load(options.cookies)
        cookies = {key: value.value for key, value in cookie.items()}

    # Headers
    headers = {h.split(':', 1)[0]: h.split(':', 1)[1].strip() for h in options.headers} if options.headers else {}

    # Methods enumeration
    methods = methods_from_http_options(console, options, proxies, headers, cookies)

    # Hardcoded default methods
    methods = ['CONNECT', 'COPY', 'DELETE', 'GET', 'LOCK', 'NOEXISTE', 'PATCH', 'PROPFIND', 'PUT']

    with ThreadPoolExecutor(max_workers=min(options.threads, len(methods))) as tp:
        for method in methods:
            tp.submit(test_method, options, method, proxies, cookies, headers, results)

    results = {key: results[key] for key in sorted(results)}
    print_results(results)

    if options.jsonfile is not None:
        json_export(results, options.jsonfile)


if __name__ == '__main__':
    try:
        options = get_options()
        logger = Logger(options.verbosity, options.quiet)
        console = Console()

        # Create a requests session with or without SSL ciphers based on verify option
        session = requests.Session()
        if not options.verify:
            requests.packages.urllib3.disable_warnings()
            session.mount('https://', CustomAdapter())

        main(options, logger, console)
    except KeyboardInterrupt:
        logger.info("Terminating script...")
        raise SystemExit
